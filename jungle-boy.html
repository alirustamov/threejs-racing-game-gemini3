<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Jungle Boy Adventure</title>
<style>
    :root {
        --bg-color: #202020;
        --game-bg: #87CEEB;
    }
    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: #fff;
        font-family: 'Courier New', Courier, monospace;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        user-select: none;
        -webkit-user-select: none;
    }
    #game-container {
        position: relative;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        border: 4px solid #444;
        background-color: #000;
    }
    canvas {
        display: block;
        image-rendering: pixelated; /* Critical for retro look */
        width: 100%;
        height: 100%;
        max-width: 1280px; /* Max aspect correct size */
        max-height: 720px;
    }
    #ui-layer {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        text-shadow: 2px 2px 0 #000;
        font-size: 18px;
        font-weight: bold;
        z-index: 10;
    }
    .hidden { display: none !important; }
    
    /* CRT Scanline effect overlay */
    #scanlines {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
        background-size: 100% 4px;
        pointer-events: none;
        opacity: 0.6;
        z-index: 20;
    }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="320" height="180"></canvas>
    <div id="scanlines"></div>
    <div id="ui-layer">
        <div id="hud" class="hidden">
            HP: <span id="hud-hp">❤❤❤</span> | SCORE: <span id="hud-score">0000</span> | HI: <span id="hud-hiscore">0000</span>
        </div>
    </div>
</div>

<script>
/**
 * JUNGLE BOY ADVENTURE
 * A single-file retro platformer.
 * * CONTROLS:
 * - Arrows: Move / Look / Climb
 * - Z: Jump / Select
 * - X: Attack
 * - P: Pause
 * - Enter: Start / Restart
 * * CONFIGURATION:
 * Modify the 'CONFIG' object below to tune gameplay.
 */

const CONFIG = {
    tileSize: 16,
    gravity: 0.25,
    friction: 0.85,
    accel: 0.5,
    jumpForce: -4.2,
    jumpCutoff: -2.0, // For variable jump height
    climbSpeed: 1.5,
    invincibilityTime: 60, // Frames
    renderScale: 3, // CSS scaling factor
    fps: 60
};

// --- ASSET GENERATION (Procedural Sprites) ---
const ASSETS = {};

// Helper to draw pixel art from string arrays
function createSprite(key, width, height, palette, mapString) {
    const cvs = document.createElement('canvas');
    cvs.width = width;
    cvs.height = height;
    const ctx = cvs.getContext('2d');
    const rows = mapString.trim().split('\n');
    for(let y=0; y<rows.length; y++) {
        for(let x=0; x<rows[y].length; x++) {
            const char = rows[y][x];
            if(palette[char]) {
                ctx.fillStyle = palette[char];
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    ASSETS[key] = cvs;
}

function initAssets() {
    // Colors: _=trans, W=white, B=black, R=red, S=skin(tan), G=green, D=darkgreen, Y=yellow, P=purple
    const p = {
        ' ': null, '.': null,
        'W': '#fff', 'B': '#000', 'R': '#e74c3c', 'S': '#f1c40f', 'T': '#d3a174',
        'G': '#2ecc71', 'D': '#27ae60', 'Y': '#f1c40f', 'P': '#9b59b6', 'O': '#e67e22',
        'L': '#3498db', '1': '#5d4037', '2': '#3e2723', '3': '#795548'
    };

    // Player Idle (16x16)
    createSprite('player_idle', 16, 16, p, `
        ....RRRR........
        ...RRRRRR.......
        ...TTTTTT.......
        ...TBTTBTT......
        ...TTTTTT.......
        ...TTTTTT.......
        ....TTTT........
        ..TTTGGTTT......
        .TTTTGGTTTT.....
        .TTTTGGTTTT.....
        .T.TTGGTT.T.....
        ...GGGGGG.......
        ...GG..GG.......
        ...TT..TT.......
        ...22..22.......
        ................
    `);
    
    // Player Run (Simplified frame)
    createSprite('player_run', 16, 16, p, `
        ....RRRR........
        ...RRRRRR.......
        ...TTTTTT.......
        ...TBTTBTT......
        ...TTTTTT.......
        ...TTTTTT.......
        ....TTTT........
        ..TTTGGTTT......
        .TTTTGGTTTT.....
        .T.TTGGTT.T.....
        ...GGGGGG.......
        ...GG..GG.......
        ..TT....TT......
        ..22....22......
        ................
    `);

    // Tile: Grass/Dirt
    createSprite('tile_ground', 16, 16, p, `
        GGGGGGGGGGGGGGGG
        DDDDDDDDDDDDDDDD
        1111111111111111
        1221212212122121
        2212121221212122
        2121221212212212
        1221212212122121
        2212121221212122
        2121221212212212
        1221212212122121
        2212121221212122
        2121221212212212
        1221212212122121
        2212121221212122
        2121221212212212
        1111111111111111
    `);

    // Tile: Vine
    createSprite('tile_vine', 16, 16, p, `
        .G..D....D..G...
        ..G..D..D..G....
        ...G..DD..G.....
        .D..G....G..D...
        ..D..G..G..D....
        ...D..GG..D.....
        .G..D....D..G...
        ..G..D..D..G....
        ...G..DD..G.....
        .D..G....G..D...
        ..D..G..G..D....
        ...D..GG..D.....
        .G..D....D..G...
        ..G..D..D..G....
        ...G..DD..G.....
        .D..G....G..D...
    `);

    // Enemy: Snake
    createSprite('enemy_snake', 16, 16, p, `
        ................
        ................
        ................
        ................
        ................
        ................
        ................
        ................
        ...P.PP.........
        ..PBP.P.........
        ..P.PPPPPP......
        .PPPPPPPPPPP....
        .P.PPPPPPP.P....
        .............T..
        ................
        ................
    `);
    
    // Enemy: Bat
    createSprite('enemy_bat', 16, 16, p, `
        ................
        .O............O.
        .OO..........OO.
        .OOO..OOOO..OOO.
        .O.OOOBBBOOO.O..
        ....OOBBBOO.....
        .....OOOOO......
        ......O.O.......
        ................
        ................
        ................
        ................
        ................
        ................
        ................
        ................
    `);

    // Item: Fruit
    createSprite('item_fruit', 16, 16, p, `
        ......G.........
        .....G..........
        ....G...........
        ...RRR..........
        ..RWRRR.........
        ..RRRRR.........
        ..RRRRR.........
        ...RRR..........
        ................
        ................
        ................
        ................
        ................
        ................
        ................
        ................
    `);
}

// --- AUDIO SYSTEM (Web Audio API) ---
const AudioSys = {
    ctx: null,
    masterGain: null,
    bgmOscs: [],
    isPlaying: false,
    
    init: function() {
        if(this.ctx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
    },

    playTone: function(freq, type, duration, vol=1.0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    sfxJump: function() { this.playTone(300, 'square', 0.15); },
    sfxLand: function() { this.playTone(100, 'sawtooth', 0.1, 0.5); },
    sfxCoin: function() { this.playTone(1200, 'square', 0.1); setTimeout(()=>this.playTone(1600, 'square', 0.2), 50); },
    sfxHit: function() { this.playTone(150, 'sawtooth', 0.2); this.playTone(100, 'sawtooth', 0.2); },
    sfxAttack: function() { this.playTone(500, 'triangle', 0.05); },
    
    // Simple Procedural Music Sequencer
    startMusic: function() {
        if(!this.ctx || this.isPlaying) return;
        this.isPlaying = true;
        const bassLine = [110, 110, 130, 110, 146, 110, 130, 123]; // Hz
        const melody = [440, 0, 440, 554, 659, 554, 440, 0];
        let step = 0;
        
        const loop = () => {
            if(!this.isPlaying) return;
            // Bass
            this.playTone(bassLine[step%8], 'triangle', 0.2, 0.4);
            // Melody (every other step)
            if(step % 2 === 0) {
                let note = melody[(step/2)%8];
                if(note > 0) this.playTone(note, 'square', 0.15, 0.2);
            }
            step++;
            setTimeout(loop, 200); // 300bpm-ish eighth notes
        };
        loop();
    },
    
    stopMusic: function() {
        this.isPlaying = false;
    }
};

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    prevKeys: {},
    
    init: function() {
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        // Add click listener to ensure focus on iframe/window
        window.addEventListener('mousedown', () => {
            window.focus();
            if(game && game.state === 'START') {
                // Also allow clicking to start if keyboard is being fussy
                game.startGame();
            }
        });
    },
    update: function() {
        this.prevKeys = {...this.keys};
    },
    isDown: function(code) { return this.keys[code]; },
    isPressed: function(code) { return this.keys[code] && !this.prevKeys[code]; }
};

// --- GAME CLASSES ---

class Sprite {
    constructor(assetKey) {
        this.img = ASSETS[assetKey];
        this.flipX = false;
    }
    draw(ctx, x, y) {
        ctx.save();
        if(this.flipX) {
            ctx.translate(Math.floor(x) + CONFIG.tileSize, Math.floor(y));
            ctx.scale(-1, 1);
            ctx.drawImage(this.img, 0, 0);
        } else {
            ctx.drawImage(this.img, Math.floor(x), Math.floor(y));
        }
        ctx.restore();
    }
}

class Entity {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.dead = false;
    }
    
    aabb(other) {
        return (this.x < other.x + other.w &&
                this.x + this.w > other.x &&
                this.y < other.y + other.h &&
                this.y + this.h > other.y);
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 10, 14); // Hitbox slightly smaller than sprite
        this.sprite = new Sprite('player_idle');
        this.facingRight = true;
        this.state = 'IDLE'; // IDLE, RUN, JUMP, CLIMB
        this.hp = 3;
        this.invincibleTimer = 0;
        this.attackTimer = 0;
        this.onVine = false;
    }

    update(map) {
        // Check environment first
        let touchingVine = map.isVine(this.x + this.w/2, this.y + this.h/2);

        // Input Movement
        if(Input.isDown('ArrowRight')) {
            this.vx += CONFIG.accel;
            this.facingRight = true;
        } else if(Input.isDown('ArrowLeft')) {
            this.vx -= CONFIG.accel;
            this.facingRight = false;
        } else {
            this.vx *= CONFIG.friction;
        }

        // Jumping
        // Allow Z, Space, or Up. 
        // Note: Up only jumps if NOT touching a vine (to allow climbing)
        const jumpPressed = Input.isPressed('KeyZ') || Input.isPressed('Space') || (Input.isPressed('ArrowUp') && !touchingVine);
        
        if(jumpPressed && (this.grounded || this.onVine)) {
            this.vy = CONFIG.jumpForce;
            this.grounded = false;
            this.onVine = false;
            AudioSys.sfxJump();
        }

        // Variable Jump Height (detect release of jump buttons)
        const jumpHeld = Input.isDown('KeyZ') || Input.isDown('Space') || (Input.isDown('ArrowUp') && !touchingVine);
        
        if(!jumpHeld && this.vy < CONFIG.jumpCutoff) {
            this.vy = CONFIG.jumpCutoff;
        }

        // Climbing Logic check
        if (touchingVine && Input.isDown('ArrowUp')) {
            this.onVine = true;
        }
        
        if (this.onVine) {
            this.vx = 0;
            this.vy = 0;
            if(Input.isDown('ArrowUp')) this.vy = -CONFIG.climbSpeed;
            if(Input.isDown('ArrowDown')) this.vy = CONFIG.climbSpeed;
            if(!touchingVine) this.onVine = false; // Fell off
        } else {
            this.vy += CONFIG.gravity;
        }

        // Attacking
        if(Input.isPressed('KeyX') && this.attackTimer === 0) {
            this.attackTimer = 15;
            AudioSys.sfxAttack();
        }
        if(this.attackTimer > 0) this.attackTimer--;
        if(this.invincibleTimer > 0) this.invincibleTimer--;

        // Physics application
        this.vx = Math.max(Math.min(this.vx, 2.5), -2.5); // Max speed
        this.vy = Math.max(Math.min(this.vy, 6), -6);     // Terminal velocity

        this.x += this.vx;
        map.collideX(this);
        this.y += this.vy;
        map.collideY(this);

        // Animation State
        this.sprite.flipX = !this.facingRight;
        if(this.onVine) {
            // Just use idle for climb to save space
            this.sprite.img = ASSETS['player_idle']; 
        } else if(!this.grounded) {
             this.sprite.img = ASSETS['player_run'];
        } else if(Math.abs(this.vx) > 0.2) {
             // Simple flicker for run anim
             this.sprite.img = (Date.now() % 200 < 100) ? ASSETS['player_run'] : ASSETS['player_idle'];
        } else {
            this.sprite.img = ASSETS['player_idle'];
        }
    }

    draw(ctx) {
        if(this.invincibleTimer > 0 && Math.floor(Date.now()/50) % 2 === 0) return; // Flicker
        
        // Offset sprite to align with hitbox (hitbox is 10x14, sprite 16x16)
        this.sprite.draw(ctx, this.x - 3, this.y - 2);

        // Attack Swoosh
        if(this.attackTimer > 0) {
            ctx.fillStyle = 'white';
            let ax = this.facingRight ? this.x + this.w : this.x - 10;
            ctx.fillRect(ax, this.y + 4, 10, 4);
        }
    }

    getAttackBox() {
        if(this.attackTimer === 0) return null;
        return {
            x: this.facingRight ? this.x + this.w : this.x - 16,
            y: this.y,
            w: 16, h: this.h
        };
    }
    
    hurt() {
        if(this.invincibleTimer > 0) return;
        this.hp--;
        this.invincibleTimer = CONFIG.invincibilityTime;
        this.vy = -3;
        this.vx = this.facingRight ? -3 : 3;
        AudioSys.sfxHit();
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 14, 14);
        this.type = type; // 'snake' or 'bat'
        this.origX = x;
        this.dir = 1;
        this.timer = 0;
        if(type === 'bat') {
            this.sprite = new Sprite('enemy_bat');
            this.vy = 0;
        } else {
            this.sprite = new Sprite('enemy_snake');
        }
    }

    update(map, player) {
        this.timer++;
        
        if(this.type === 'snake') {
            // Patrol
            this.vx = 0.5 * this.dir;
            this.x += this.vx;
            
            // Turn around at walls or edges
            if(map.checkSolid(this.x + (this.dir>0?this.w:0), this.y + this.h - 2) ||
               !map.checkSolid(this.x + (this.dir>0?this.w:0), this.y + this.h + 1)) {
                this.dir *= -1;
            }
            
            this.y += this.vy;
            this.vy += CONFIG.gravity;
            map.collideY(this);
            
            this.sprite.flipX = (this.dir < 0);
        } 
        else if (this.type === 'bat') {
            // Fly Sine wave
            this.x += 1 * this.dir;
            this.y = (this.origX % 100) + 20 + Math.sin(this.timer * 0.05) * 20; 
            
            if(Math.abs(this.x - this.origX) > 60) this.dir *= -1;
        }
    }

    draw(ctx) {
        this.sprite.draw(ctx, this.x, this.y);
    }
}

class Pickup extends Entity {
    constructor(x, y) {
        super(x, y, 12, 12);
        this.sprite = new Sprite('item_fruit');
        this.baseY = y;
        this.timer = 0;
    }
    update() {
        this.timer += 0.1;
        this.y = this.baseY + Math.sin(this.timer) * 2;
    }
    draw(ctx) {
        this.sprite.draw(ctx, this.x, this.y);
    }
}

class Map {
    constructor() {
        this.tileSize = CONFIG.tileSize;
        this.width = 0;
        this.height = 0;
        this.data = [];
    }

    load(levelStr) {
        const lines = levelStr.trim().split('\n');
        this.height = lines.length;
        this.width = lines[0].length;
        this.data = [];
        
        // Parse map
        const entities = { enemies: [], pickups: [], playerStart: {x:50, y:50} };
        
        for(let y=0; y<this.height; y++) {
            let row = [];
            for(let x=0; x<this.width; x++) {
                let char = lines[y][x];
                // Logic tiles
                if(char === 'P') { entities.playerStart = {x: x*this.tileSize, y: y*this.tileSize}; char='.'; }
                else if(char === 'S') { entities.enemies.push(new Enemy(x*this.tileSize, y*this.tileSize, 'snake')); char='.'; }
                else if(char === 'B') { entities.enemies.push(new Enemy(x*this.tileSize, y*this.tileSize, 'bat')); char='.'; }
                else if(char === 'F') { entities.pickups.push(new Pickup(x*this.tileSize, y*this.tileSize)); char='.'; }
                
                row.push(char);
            }
            this.data.push(row);
        }
        return entities;
    }

    isSolid(tile) { return tile === '#' || tile === 'G'; }
    isVine(x, y) { 
        let tx = Math.floor(x/this.tileSize);
        let ty = Math.floor(y/this.tileSize);
        if(ty < 0 || ty >= this.height || tx < 0 || tx >= this.width) return false;
        return this.data[ty][tx] === 'V';
    }

    checkSolid(x, y) {
        let tx = Math.floor(x/this.tileSize);
        let ty = Math.floor(y/this.tileSize);
        if(ty < 0 || ty >= this.height || tx < 0 || tx >= this.width) return false;
        return this.isSolid(this.data[ty][tx]);
    }
    
    getTile(x, y) {
        let tx = Math.floor(x/this.tileSize);
        let ty = Math.floor(y/this.tileSize);
        if(ty < 0 || ty >= this.height || tx < 0 || tx >= this.width) return '.';
        return this.data[ty][tx];
    }

    collideX(ent) {
        // Check left/right
        if(ent.vx > 0) { // moving right
            if(this.checkSolid(ent.x + ent.w, ent.y) || this.checkSolid(ent.x + ent.w, ent.y + ent.h - 1)) {
                ent.x = (Math.floor((ent.x + ent.w) / this.tileSize) * this.tileSize) - ent.w - 0.1;
                ent.vx = 0;
            }
        } else if (ent.vx < 0) {
            if(this.checkSolid(ent.x, ent.y) || this.checkSolid(ent.x, ent.y + ent.h - 1)) {
                ent.x = (Math.floor(ent.x / this.tileSize) + 1) * this.tileSize;
                ent.vx = 0;
            }
        }
        // Bounds
        if(ent.x < 0) ent.x = 0;
        if(ent.x > this.width * this.tileSize - ent.w) ent.x = this.width * this.tileSize - ent.w;
    }

    collideY(ent) {
        ent.grounded = false;
        if(ent.vy > 0) { // Falling
            if(this.checkSolid(ent.x + 2, ent.y + ent.h) || this.checkSolid(ent.x + ent.w - 2, ent.y + ent.h)) {
                ent.y = (Math.floor((ent.y + ent.h) / this.tileSize) * this.tileSize) - ent.h;
                ent.vy = 0;
                ent.grounded = true;
            }
        } else if (ent.vy < 0) { // Jumping up
             if(this.checkSolid(ent.x + 2, ent.y) || this.checkSolid(ent.x + ent.w - 2, ent.y)) {
                ent.y = (Math.floor(ent.y / this.tileSize) + 1) * this.tileSize;
                ent.vy = 0;
            }
        }
        
        // Spike hazard check (simple tile check)
        if(this.getTile(ent.x + ent.w/2, ent.y + ent.h/2) === 'X') {
             if(ent instanceof Player) ent.hurt();
        }
    }

    draw(ctx, camX, camY) {
        const startX = Math.floor(camX / this.tileSize);
        const endX = startX + (320 / this.tileSize) + 1;
        
        for(let y=0; y<this.height; y++) {
            for(let x=startX; x<endX; x++) {
                if(x < 0 || x >= this.width) continue;
                const t = this.data[y][x];
                const px = Math.floor(x * this.tileSize);
                const py = Math.floor(y * this.tileSize);
                
                if(t === '#') ctx.drawImage(ASSETS['tile_ground'], px, py);
                else if(t === 'G') ctx.drawImage(ASSETS['tile_ground'], px, py);
                else if(t === 'V') ctx.drawImage(ASSETS['tile_vine'], px, py);
                else if(t === 'X') {
                    // Spikes
                    ctx.fillStyle = '#95a5a6';
                    ctx.beginPath();
                    ctx.moveTo(px, py+16);
                    ctx.lineTo(px+8, py);
                    ctx.lineTo(px+16, py+16);
                    ctx.fill();
                }
            }
        }
    }
}

// --- MAIN GAME LOOP ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.state = 'START'; // START, PLAY, GAMEOVER, WIN
        this.levelIndex = 0;
        this.score = 0;
        this.hiScore = parseInt(localStorage.getItem('jungle_highscore_v1')) || 0;
        
        this.map = new Map();
        this.player = null;
        this.enemies = [];
        this.pickups = [];
        this.particles = []; // Todo
        
        this.camX = 0;
        this.camY = 0;
        
        // Simple One-Level Layout
        // G=Ground(Solid), V=Vine, X=Spikes, .=Air, #=Solid, S=Snake, B=Bat, F=Fruit, P=PlayerStart
        this.levelData = `
....................................................................................................................................................
....................................................................................................................................................
....................................................................................................................................................
...................................................................................FFF..............................................................
..............................................................................V########.............................................................
..............................................................................V.....................................................................
..............................................................................V.....................................................................
..................................................................F...........V...........B.........................................................
.............................................................VV#######........V.....................................................................
...........................FFF...................#...........V...............##.....................................................................
..........................#####................###......B....V..............###.......................#.............................................
.............................................#####...........V.............####.....................###.............................................
.......................B...................#######...........V............#####...................#####.............................................
..P.......................................########...........V...........######...........B......######.............................................
.......F......S............S.............#########..XXXXXX...V...S......#######................########.............................................
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG.GGGGGG#########GGGGGGGGGGGGGGGGGGGGGG#######.......S.......#########GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
`;

        this.init();
    }

    init() {
        initAssets();
        Input.init();
        this.updateHUD();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    loadLevel() {
        const entities = this.map.load(this.levelData);
        this.player = new Player(entities.playerStart.x, entities.playerStart.y);
        this.enemies = entities.enemies;
        this.pickups = entities.pickups;
        this.score = 0;
        this.updateHUD();
        AudioSys.startMusic();
    }

    startGame() {
        AudioSys.init();
        this.loadLevel();
        this.state = 'PLAY';
    }

    update() {
        if(this.state === 'START') {
            if(Input.isPressed('Enter') || Input.isPressed('KeyZ')) {
                this.startGame();
            }
            return;
        }

        if(this.state === 'GAMEOVER') {
            if(Input.isPressed('Enter')) {
                this.loadLevel();
                this.state = 'PLAY';
            }
            return;
        }

        if(Input.isPressed('KeyP')) {
            this.state = (this.state === 'PAUSED') ? 'PLAY' : 'PAUSED';
            if(this.state === 'PAUSED') AudioSys.stopMusic();
            else AudioSys.startMusic();
        }

        if(this.state !== 'PLAY') return;

        // Updates
        this.player.update(this.map);

        // Enemy Logic & Collision
        const attackBox = this.player.getAttackBox();

        for(let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            e.update(this.map, this.player);

            // Attack Collision
            if(attackBox && e.aabb(attackBox)) {
                this.enemies.splice(i, 1);
                this.score += 100;
                AudioSys.sfxHit(); // Enemy hit sound
                continue;
            }

            // Player Body Collision
            if(!e.dead && e.aabb(this.player)) {
                // Jump on head?
                if(this.player.vy > 0 && this.player.y + this.player.h < e.y + e.h/2) {
                    this.enemies.splice(i, 1);
                    this.player.vy = -2.5; // Bounce
                    this.score += 100;
                    AudioSys.sfxHit();
                } else {
                    this.player.hurt();
                }
            }
        }

        // Pickups
        for(let i = this.pickups.length - 1; i >= 0; i--) {
            let p = this.pickups[i];
            p.update();
            if(p.aabb(this.player)) {
                this.pickups.splice(i, 1);
                this.score += 50;
                AudioSys.sfxCoin();
                if(this.player.hp < 3) this.player.hp++;
            }
        }

        // Check Death
        if(this.player.y > this.map.height * CONFIG.tileSize + 20 || this.player.hp <= 0) {
            this.state = 'GAMEOVER';
            AudioSys.stopMusic();
            // Save Hi Score
            if(this.score > this.hiScore) {
                this.hiScore = this.score;
                localStorage.setItem('jungle_highscore_v1', this.hiScore);
            }
        }

        // Camera Follow (Horizontal & Vertical)
        let targetCamX = this.player.x - 320/2 + this.player.w/2;
        let targetCamY = this.player.y - 180/2 + this.player.h/2;
        
        this.camX += (targetCamX - this.camX) * 0.1;
        this.camY += (targetCamY - this.camY) * 0.1;
        
        // Clamp Camera to Map Bounds
        this.camX = Math.max(0, Math.min(this.camX, this.map.width * CONFIG.tileSize - 320));
        this.camY = Math.max(0, Math.min(this.camY, this.map.height * CONFIG.tileSize - 180));
        
        this.updateHUD();
    }

    updateHUD() {
        const hudEl = document.getElementById('hud');
        if(this.state === 'PLAY') {
            hudEl.classList.remove('hidden');
            let hpStr = '';
            for(let i=0; i<this.player.hp; i++) hpStr += '❤';
            document.getElementById('hud-hp').innerText = hpStr;
            document.getElementById('hud-score').innerText = this.score.toString().padStart(4, '0');
            document.getElementById('hud-hiscore').innerText = this.hiScore.toString().padStart(4, '0');
        } else {
            hudEl.classList.add('hidden');
        }
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, 320, 180);

        // Draw Background (Sky)
        ctx.fillStyle = '#87CEEB'; // Sky Blue
        ctx.fillRect(0, 0, 320, 180);

        // Draw Parallax Clouds/Hills (Vertical offset applied lightly)
        ctx.fillStyle = '#5dade2';
        ctx.fillRect(50 - this.camX*0.1, 50 - (this.camY * 0.05), 60, 20);
        ctx.fillRect(200 - this.camX*0.1, 30 - (this.camY * 0.05), 80, 30);
        
        // Midground Trees (Vertical parallax)
        ctx.fillStyle = '#1e8449';
        for(let i=0; i<20; i++) {
            ctx.fillRect((i*100) - (this.camX * 0.5), 100 - (this.camY * 0.2), 40, 80);
        }

        if(this.state === 'START') {
            this.drawTextCentered('JUNGLE RUNNER', 60, 24, '#f1c40f');
            this.drawTextCentered('PRESS ENTER TO START', 100, 10, '#fff');
            this.drawTextCentered('Move: ARROWS  Jump: SPACE/Z/UP', 120, 8, '#ccc');
            this.drawTextCentered('Attack: X', 135, 8, '#ccc');
            this.drawTextCentered('(Click here if controls don\'t respond)', 160, 6, '#555');
            return;
        }

        ctx.save();
        ctx.translate(-Math.floor(this.camX), -Math.floor(this.camY));

        // Map
        this.map.draw(ctx, this.camX, this.camY);

        // Entities
        for(let p of this.pickups) p.draw(ctx);
        for(let e of this.enemies) e.draw(ctx);
        if(this.player && this.player.hp > 0) this.player.draw(ctx);

        ctx.restore();

        if(this.state === 'PAUSED') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,320,180);
            this.drawTextCentered('PAUSED', 90, 16, '#fff');
        }

        if(this.state === 'GAMEOVER') {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0,0,320,180);
            this.drawTextCentered('GAME OVER', 70, 20, '#e74c3c');
            this.drawTextCentered('SCORE: ' + this.score, 90, 12, '#fff');
            this.drawTextCentered('PRESS ENTER TO RESTART', 120, 10, '#ccc');
        }
    }

    drawTextCentered(text, y, size, color) {
        this.ctx.fillStyle = color;
        this.ctx.font = `bold ${size}px monospace`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(text, 160, y);
        this.ctx.textAlign = 'left';
    }

    loop() {
        this.update();
        this.draw();
        // Fix: Update keys at end of frame
        Input.update(); 
        requestAnimationFrame(this.loop);
    }
}

let game = null;
// Start Game
window.onload = () => {
    game = new Game();
};

</script>
</body>
</html>