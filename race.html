<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Arcade Racer - Physics Update</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0 0 5px 0; font-size: 20px; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 0; font-size: 14px; color: #ddd; }
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            font-style: italic;
            text-shadow: 2px 2px 0 #000;
        }
    </style>
</head>
<body>

    <div id="info">
        <h1>Arcade Racer</h1>
        <p>Controls: <b>W (Gas), S (Brake/Reverse), A/D (Steer)</b></p>
        <p>Stay on the grey road!</p>
    </div>
    <div id="speedometer">0 km/h</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const CONFIG = {
            roadWidth: 14,
            aiCount: 5,
            
            // Physics Constants
            maxSpeed: 1.6,
            reverseSpeed: 0.6,
            
            accel: 0.02,         // Engine power
            brakingDecel: 0.06,  // Brakes (Stronger than coasting)
            reverseAccel: 0.015, // Reverse engine power
            
            friction: 0.99,      // Coasting resistance (1.0 = no friction)
            offRoadDrag: 0.92,   // Heavy slowdown offroad
            
            turnSpeed: 0.045     // Steering sensitivity
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- TRACK ---
        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(10, 0, -50),
            new THREE.Vector3(60, 0, -80),
            new THREE.Vector3(110, 0, -40),
            new THREE.Vector3(110, 0, 20),
            new THREE.Vector3(60, 0, 50),
            new THREE.Vector3(10, 0, 20),
            new THREE.Vector3(-40, 0, 40),
            new THREE.Vector3(-80, 0, 0),
            new THREE.Vector3(-40, 0, -40)
        ];

        const curve = new THREE.CatmullRomCurve3(points);
        curve.closed = true;
        curve.tension = 0.5;

        const roadGeo = new THREE.TubeGeometry(curve, 150, CONFIG.roadWidth / 2, 4, true);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8, side: THREE.DoubleSide });
        const roadMesh = new THREE.Mesh(roadGeo, roadMat);
        roadMesh.scale.set(1, 0.01, 1); 
        roadMesh.position.y = 0.1;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        const borderGeo = new THREE.TubeGeometry(curve, 150, (CONFIG.roadWidth / 2) + 1, 4, true);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, wireframe: true });
        const borderMesh = new THREE.Mesh(borderGeo, borderMat);
        borderMesh.scale.set(1, 0.01, 1);
        borderMesh.position.y = 0.05;
        scene.add(borderMesh);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(600, 600),
            new THREE.MeshStandardMaterial({ color: 0x2b8a1e })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- CAR FACTORY ---
        function createCarMesh(color) {
            const carGroup = new THREE.Group();

            // Main Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.8, 4.5),
                new THREE.MeshStandardMaterial({ color: color, metalness: 0.4, roughness: 0.2 })
            );
            body.position.y = 0.8;
            body.castShadow = true;
            carGroup.add(body);

            // Cabin
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.7, 2.5),
                new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.1 })
            );
            cabin.position.set(0, 1.5, -0.3);
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Spoiler
            const spoiler = new THREE.Mesh(
                new THREE.BoxGeometry(2.4, 0.1, 0.8),
                new THREE.MeshStandardMaterial({ color: color })
            );
            spoiler.position.set(0, 1.6, 2);
            carGroup.add(spoiler);

            // Headlights (Yellow)
            const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const leftLight = new THREE.Mesh(lightGeo, lightMat);
            leftLight.position.set(-0.8, 0.8, -2.26); 
            carGroup.add(leftLight);
            const rightLight = new THREE.Mesh(lightGeo, lightMat);
            rightLight.position.set(0.8, 0.8, -2.26); 
            carGroup.add(rightLight);

            // Taillights (Red)
            const tailLightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const tl = new THREE.Mesh(lightGeo, tailLightMat);
            tl.position.set(-0.8, 0.8, 2.26);
            carGroup.add(tl);
            const tr = new THREE.Mesh(lightGeo, tailLightMat);
            tr.position.set(0.8, 0.8, 2.26);
            carGroup.add(tr);

            return carGroup;
        }

        // --- PLAYER INIT ---
        const playerMesh = createCarMesh(0xe74c3c); // Red
        scene.add(playerMesh);
        
        const player = {
            mesh: playerMesh,
            speed: 0
        };

        // --- AI INIT ---
        const aiCars = [];
        const aiColors = [0x3498db, 0xf1c40f, 0x9b59b6, 0xffffff];
        for(let i = 0; i < CONFIG.aiCount; i++) {
            const mesh = createCarMesh(aiColors[i % aiColors.length]);
            scene.add(mesh);
            aiCars.push({
                mesh: mesh,
                progress: i * (1 / CONFIG.aiCount),
                speed: 0.0004 + (Math.random() * 0.0003),
                offset: (Math.random() - 0.5) * 1.5
            });
        }

        // --- CONTROLS ---
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
        });
        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
        });

        // --- GAME LOOP ---
        const speedEl = document.getElementById('speedometer');

        function getTrackDistance(pos) {
            let minDst = Infinity;
            for(let i=0; i<=50; i++){
                const t = i/50;
                const p = curve.getPointAt(t);
                const d = p.distanceTo(pos);
                if(d < minDst) minDst = d;
            }
            return minDst;
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- 1. ACCELERATION / BRAKING LOGIC ---
            
            if (keys.w) {
                // W pressed
                if (player.speed < 0) {
                    // If reversing, W acts as brake
                    player.speed += CONFIG.brakingDecel;
                    if(player.speed > 0) player.speed = 0;
                } else {
                    // Normal Acceleration
                    player.speed += CONFIG.accel;
                }
            } 
            else if (keys.s) {
                // S pressed
                if (player.speed > 0) {
                    // If moving forward, S acts as BRAKE
                    player.speed -= CONFIG.brakingDecel;
                    // Clamp to 0 so we don't immediately start reversing
                    if (player.speed < 0) player.speed = 0; 
                } else {
                    // If stopped or already reversing, S acts as REVERSE ACCEL
                    player.speed -= CONFIG.reverseAccel;
                }
            } 
            else {
                // No keys pressed: Friction (Coasting)
                player.speed *= CONFIG.friction;
                
                // Snap to zero if barely moving
                if (Math.abs(player.speed) < 0.001) player.speed = 0;
            }

            // --- 2. OFFROAD PHYSICS ---
            const dist = getTrackDistance(player.mesh.position);
            if (dist > CONFIG.roadWidth / 2) {
                player.speed *= CONFIG.offRoadDrag;
            }

            // --- 3. SPEED LIMITS ---
            // Forward limit
            if (player.speed > CONFIG.maxSpeed) player.speed = CONFIG.maxSpeed;
            // Reverse limit
            if (player.speed < -CONFIG.reverseSpeed) player.speed = -CONFIG.reverseSpeed;

            // --- 4. STEERING ---
            // Only steer if the car is actually moving
            if (Math.abs(player.speed) > 0.01) {
                // If reversing, invert steering direction for realism? 
                // Standard arcade usually inverts control when reversing so pressing D still goes "Right" relative to camera.
                // But physically, D turns wheels right.
                const dir = player.speed > 0 ? 1 : -1;
                
                if (keys.a) player.mesh.rotation.y -= CONFIG.turnSpeed * dir; // Left
                if (keys.d) player.mesh.rotation.y += CONFIG.turnSpeed * dir; // Right
            }

            // --- 5. APPLY MOVEMENT ---
            // translateZ moves object along its own local Z axis. 
            // Forward is negative Z in ThreeJS.
            player.mesh.translateZ(-player.speed);

            // --- CAMERA FOLLOW ---
            const relativeOffset = new THREE.Vector3(0, 6, 12); 
            const cameraOffset = relativeOffset.applyMatrix4(player.mesh.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.mesh.position);

            // --- UI ---
            speedEl.innerText = Math.round(player.speed * 100) + " km/h";

            // --- AI LOGIC ---
            aiCars.forEach(ai => {
                ai.progress += ai.speed;
                if (ai.progress > 1) ai.progress = 0;
                
                const pt = curve.getPointAt(ai.progress);
                const tangent = curve.getTangentAt(ai.progress).normalize();
                const right = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0));
                
                ai.mesh.position.copy(pt).add(right.multiplyScalar(ai.offset));
                const lookPt = curve.getPointAt((ai.progress + 0.01)%1).add(right.multiplyScalar(ai.offset));
                ai.mesh.lookAt(lookPt);
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Place player
        const startPos = points[0].clone();
        player.mesh.position.copy(startPos);
        player.mesh.lookAt(points[1]);

        animate();
    </script>
</body>
</html>
