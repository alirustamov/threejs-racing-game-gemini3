<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Three.js Racer - Responsive</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; touch-action: none; background-color: #000; }
        
        /* UI Overlays */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
            font-size: 12px;
            z-index: 9999;
        }
        
        #speedometer {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            font-style: italic;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 9999;
        }

        /* JOYSTICK CONTAINER */
        #joystick-zone {
            position: absolute;
            bottom: 15%; 
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5); 
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            touch-action: none;
            z-index: 9999;
            cursor: pointer;
            /* Default: Visible on mobile */
            display: block;
        }

        /* Hide Joystick on Large Screens (Desktops/Laptops) */
        @media (min-width: 1024px) {
            #joystick-zone {
                display: none !important;
            }
            #info h1:after {
                content: " (Desktop Mode)";
                font-size: 10px;
                color: #aaa;
            }
        }

        /* JOYSTICK KNOB */
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: #ff3333;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; 
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

    <div id="info">
        <h1>Arcade Racer</h1>
        <p>Use W/S to Drive, A/D to Steer.</p>
        <p>On Mobile: Use the red joystick.</p>
    </div>
    <div id="speedometer">0 km/h</div>

    <!-- Virtual Joystick HTML -->
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const CONFIG = {
            roadWidth: 14,
            aiCount: 5,
            maxSpeed: 1.6,
            reverseSpeed: 0.6,
            accel: 0.02,
            brakingDecel: 0.06,
            reverseAccel: 0.015,
            friction: 0.99,
            offRoadDrag: 0.92,
            turnSpeed: 0.045
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.mapSize.width = 1024; 
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- TRACK ---
        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(10, 0, -50),
            new THREE.Vector3(60, 0, -80),
            new THREE.Vector3(110, 0, -40),
            new THREE.Vector3(110, 0, 20),
            new THREE.Vector3(60, 0, 50),
            new THREE.Vector3(10, 0, 20),
            new THREE.Vector3(-40, 0, 40),
            new THREE.Vector3(-80, 0, 0),
            new THREE.Vector3(-40, 0, -40)
        ];
        const curve = new THREE.CatmullRomCurve3(points);
        curve.closed = true;
        curve.tension = 0.5;

        const roadGeo = new THREE.TubeGeometry(curve, 150, CONFIG.roadWidth / 2, 4, true);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8, side: THREE.DoubleSide });
        const roadMesh = new THREE.Mesh(roadGeo, roadMat);
        roadMesh.scale.set(1, 0.01, 1); 
        roadMesh.position.y = 0.1;
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);

        const borderGeo = new THREE.TubeGeometry(curve, 150, (CONFIG.roadWidth / 2) + 1, 4, true);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, wireframe: true });
        const borderMesh = new THREE.Mesh(borderGeo, borderMat);
        borderMesh.scale.set(1, 0.01, 1);
        borderMesh.position.y = 0.05;
        scene.add(borderMesh);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(600, 600),
            new THREE.MeshStandardMaterial({ color: 0x2b8a1e })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- CARS ---
        function createCarMesh(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 4.5), new THREE.MeshStandardMaterial({ color: color, metalness: 0.4, roughness: 0.2 }));
            body.position.y = 0.8; body.castShadow = true; group.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2.5), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            cabin.position.set(0, 1.5, -0.3); cabin.castShadow = true; group.add(cabin);
            const spoiler = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: color }));
            spoiler.position.set(0, 1.6, 2); group.add(spoiler);
            const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const yel = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const red = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const fl = new THREE.Mesh(lightGeo, yel); fl.position.set(-0.8, 0.8, -2.26); group.add(fl);
            const fr = new THREE.Mesh(lightGeo, yel); fr.position.set(0.8, 0.8, -2.26); group.add(fr);
            const bl = new THREE.Mesh(lightGeo, red); bl.position.set(-0.8, 0.8, 2.26); group.add(bl);
            const br = new THREE.Mesh(lightGeo, red); br.position.set(0.8, 0.8, 2.26); group.add(br);
            return group;
        }

        const playerMesh = createCarMesh(0xe74c3c);
        scene.add(playerMesh);
        const player = { mesh: playerMesh, speed: 0 };

        const aiCars = [];
        const aiColors = [0x3498db, 0xf1c40f, 0x9b59b6, 0xffffff];
        for(let i = 0; i < CONFIG.aiCount; i++) {
            const mesh = createCarMesh(aiColors[i % aiColors.length]);
            scene.add(mesh);
            aiCars.push({ mesh: mesh, progress: i * (1/CONFIG.aiCount), speed: 0.0004 + Math.random()*0.0003, offset: (Math.random()-0.5)*1.5 });
        }

        // --- INPUT: JOYSTICK + KEYBOARD ---
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });

        // Joystick Logic
        const joystick = { x: 0, y: 0, active: false };
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        const maxRadius = 35; 

        function handleStart(clientX, clientY) {
            // Prevent interaction if hidden via CSS
            if (getComputedStyle(joyZone).display === 'none') return;
            
            joystick.active = true;
            handleMove(clientX, clientY);
        }

        function handleMove(clientX, clientY) {
            if (!joystick.active) return;
            const rect = joyZone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance > maxRadius) {
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * maxRadius;
                dy = Math.sin(angle) * maxRadius;
            }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystick.x = dx / maxRadius;
            joystick.y = dy / maxRadius;
        }

        function handleEnd() {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
        }

        // Touch Events
        joyZone.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        joyZone.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        joyZone.addEventListener('touchend', handleEnd);
        
        // Mouse Events (For testing on small browser windows on PC)
        joyZone.addEventListener('mousedown', (e) => { e.preventDefault(); handleStart(e.clientX, e.clientY); });
        window.addEventListener('mousemove', (e) => { if(joystick.active) { e.preventDefault(); handleMove(e.clientX, e.clientY); } });
        window.addEventListener('mouseup', handleEnd);


        // --- GAME LOOP ---
        const speedEl = document.getElementById('speedometer');
        function getTrackDistance(pos) {
            let minDst = Infinity;
            for(let i=0; i<=50; i++){
                const t = i/50;
                const p = curve.getPointAt(t);
                const d = p.distanceTo(pos);
                if(d < minDst) minDst = d;
            }
            return minDst;
        }

        function animate() {
            requestAnimationFrame(animate);

            // INPUT MERGE
            // Joystick input is 0 if invisible/inactive, so keys work fine on desktop
            const isGas = keys.w || (joystick.y < -0.2);
            const isBrake = keys.s || (joystick.y > 0.2);
            let steerInput = 0;
            if (keys.a) steerInput = -1;
            if (keys.d) steerInput = 1;
            if (Math.abs(joystick.x) > 0.1) steerInput = joystick.x;

            // PHYSICS
            if (isGas) {
                if (player.speed < 0) {
                    player.speed += CONFIG.brakingDecel;
                    if(player.speed > 0) player.speed = 0;
                } else {
                    const intensity = joystick.active ? Math.abs(joystick.y) : 1.0;
                    player.speed += CONFIG.accel * intensity;
                }
            } else if (isBrake) {
                if (player.speed > 0) {
                    player.speed -= CONFIG.brakingDecel;
                    if (player.speed < 0) player.speed = 0;
                } else {
                    const intensity = joystick.active ? Math.abs(joystick.y) : 1.0;
                    player.speed -= CONFIG.reverseAccel * intensity;
                }
            } else {
                player.speed *= CONFIG.friction;
                if (Math.abs(player.speed) < 0.001) player.speed = 0;
            }

            if (getTrackDistance(player.mesh.position) > CONFIG.roadWidth / 2) {
                player.speed *= CONFIG.offRoadDrag;
            }
            player.speed = Math.max(Math.min(player.speed, CONFIG.maxSpeed), -CONFIG.reverseSpeed);

            if (Math.abs(player.speed) > 0.01) {
                const dir = player.speed > 0 ? 1 : -1;
                player.mesh.rotation.y += (CONFIG.turnSpeed * steerInput * dir);
            }
            player.mesh.translateZ(-player.speed);

            // CAMERA & RENDER
            const relativeOffset = new THREE.Vector3(0, 6, 12); 
            const cameraOffset = relativeOffset.applyMatrix4(player.mesh.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.mesh.position);

            speedEl.innerText = Math.round(player.speed * 100) + " km/h";

            aiCars.forEach(ai => {
                ai.progress += ai.speed;
                if (ai.progress > 1) ai.progress = 0;
                const pt = curve.getPointAt(ai.progress);
                const tangent = curve.getTangentAt(ai.progress).normalize();
                const right = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0));
                ai.mesh.position.copy(pt).add(right.multiplyScalar(ai.offset));
                const lookPt = curve.getPointAt((ai.progress + 0.01)%1).add(right.multiplyScalar(ai.offset));
                ai.mesh.lookAt(lookPt);
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        player.mesh.position.copy(points[0]);
        player.mesh.lookAt(points[1]);
        animate();
    </script>
</body>
</html>